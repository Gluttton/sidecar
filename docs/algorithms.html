<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SideCar: Algorithms Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SideCar
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Radar SideCar Project</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Algorithms Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="new"></a>
Creating a New Algorithm</h1>
<p>The simplest way to create a new algorithm is to first become familiar with existing ones, and then duplicate one that is similar to the task you wish to accomplish with the new algorithm.</p>
<p>You may also use the newalg utility to create a set of C++ files that will get you started. To use, simply run the script with the name of the algorithm you would like to create:</p>
<div class="fragment"><div class="line">% newalg Foobar</div></div><!-- fragment --><p>The newalg script creates a new directory for the algorithm in the Algorithms top-level directory. In the new directory, it places four files there:</p>
<ul>
<li><code>Foobar.cc</code> the C++ source file for the algorithm</li>
<li><code>Foobar.h</code> the C++ include file for the algorithm</li>
<li><code>FoobarTest.cc</code> a basic unit test for the algorithm</li>
<li><code>Jamfile</code> Boost Build script for the algorithm</li>
</ul>
<p>The C++ source files implement a basic algorithm that simply adds 100 to each incoming video message sample. However, it is well-documented, and it provides much of what most algorithms will need to do their job.</p>
<h1><a class="anchor" id="channels"></a>
Data Channels</h1>
<p>Information flows into and out of an algorithm on a data channel, a named conduit that directs data flow among IO::Task objects in the same IO::Stream object. Data channels are an enhancement to the normal data flow mechanism found in ACE Stream and Task objects, which simply connects the output of one Task object to the input of its downstream neighbor. The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> enhancement allows for faster message delivery, since only recipients of a message will receive it, not every Task object downstream from the message emitter.</p>
<p>Creation of data channels occurs at IO::Stream creation by the StreamBuilder class used by the Runner application. Channel names and types are assigned per the XML configuration file used by the Runner application to create and instantiate IO::Stream objects (the <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> API allows for dynamic data channel creation, but doing so is not supported at this time)</p>
<p>For input data channels, use the two-argument registerProcessor template method to assign a message processor to a named data channel. If there is no named channel at the time of the registration, an exception is thrown, indicating a disconnect between what the algorithm expects for inputs and what an XML input file has configured. For example, the side-lobe cancelling algorithm (see Algorithms::SLC) accepts data from a main video channel, and up to 8 auxillary channels. In its startup() method, it has the following processor registrations:</p>
<div class="fragment"><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;main&quot;</span>, &amp;SLC::main);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux1&quot;</span>, &amp;SLC::aux1);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux2&quot;</span>, &amp;SLC::aux2);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux3&quot;</span>, &amp;SLC::aux3);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux4&quot;</span>, &amp;SLC::aux4);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux5&quot;</span>, &amp;SLC::aux5);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux6&quot;</span>, &amp;SLC::aux6);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux7&quot;</span>, &amp;SLC::aux7);</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(<span class="stringliteral">&quot;aux8&quot;</span>, &amp;SLC::aux8);</div></div><!-- fragment --><p>An alternative way to do the above would be to use the channel introspection routines found in IO::Task to determine the name and number of the input channels defined, and to only register those channels, like so:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> index = 0; index &lt; getController().getNumInputChannels();</div><div class="line">++index) {</div><div class="line"><span class="keyword">const</span> Channel&amp; channel(getController().getInputChannel(index));</div><div class="line"><span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;main&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::main);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux1&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux1);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux2&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux2);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux3&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux3);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux4&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux4);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux5&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux5);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux6&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux6);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux7&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux7);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel.getName() == <span class="stringliteral">&quot;aux8&quot;</span>)</div><div class="line">registerProcessor&lt;SLC,Messages::Video&gt;(index, &amp;SLC::aux8);</div><div class="line"><span class="keywordflow">else</span></div><div class="line"><span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p>Although the name checking above is tedious and slow, it is only performed at startup, where speed is not really an issue. The big benefit to the above is that the XML configuration does not need to define all eight auxillary data channels for the SLC algorithm to run; it only needs to define channels that will have data on them.</p>
<h1><a class="anchor" id="parameters"></a>
Runtime Parameters</h1>
<p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> framework contains a suite of templates and classes (see <a class="el" href="namespaceSideCar_1_1Parameter.html" title="Definitions for algorithm runtime parameter settings. ">SideCar::Parameter</a>) that allow for runtime configurable parameters. These Parameter objects have XML-RPC support so that their value may be changed by an external process, such as the <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application. These objects also offer a signalling mechanism to notify algorithms when the Parameter's value changes.</p>
<p>Like any other object attribute, a runtime parameter is declared in the algorithm's C++ header file, preferably at the bottom after the <code>private:</code> access declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line"><a class="code" href="namespaceSideCar_1_1Parameter.html#a6b770a319c0009ffe02d4857ac4c8cf3">Parameters::IntValue::Ref</a> param1_;</div><div class="line"><a class="code" href="namespaceSideCar_1_1Parameter.html#a6b770a319c0009ffe02d4857ac4c8cf3">Parameters::DoubleValue::Ref</a> param2_;</div></div><!-- fragment --><p>The declaration must have a matching initializer in the algorithm's constructor:</p>
<div class="fragment"><div class="line">Foobar::Foobar(Controller&amp; controller, <a class="code" href="classLogger_1_1Log.html">Logger::Log</a>&amp; log)</div><div class="line">: Algorithm(controller, log),</div><div class="line">param1_(Parameter::<a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">IntValue</a>::Make(<span class="stringliteral">&quot;param1&quot;</span>, 123)),</div><div class="line">param2_(Parameter::<a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">IntValue</a>::Make(<span class="stringliteral">&quot;param2&quot;</span>, 3.1415926))</div><div class="line">{}</div></div><!-- fragment --><p>The first argument to a parameter's Make factory method is the name the parameter will have when viewed by an external editor. It does not have to match the name of the parameter declared in the C++ header file; instead, it should be somewhat descriptive of what the value does in the algorithm. The second argument to the Make factor method is the initial value to give to the parameter at initialization time. Note that the XML configuration file used by the <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application to start up algorithms may contain initialization values as well, and these values will override those given to the Make factory method.</p>
<p>If an algorithm needs to know when a parameter value is changed, it must register a notification method to the parameter's change signal, preferably in the algorithm's constructor body:</p>
<div class="fragment"><div class="line">Foobar::Foobar(Controller&amp; controller, <a class="code" href="classLogger_1_1Log.html">Logger::Log</a>&amp; log)</div><div class="line">: Algorithm(controller, log),</div><div class="line">param1_(Parameter::<a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">IntValue</a>::Make(<span class="stringliteral">&quot;param1&quot;</span>, 123)),</div><div class="line">param2_(Parameter::<a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">IntValue</a>::Make(<span class="stringliteral">&quot;param2&quot;</span>, 3.1415926))</div><div class="line">{</div><div class="line">param1_-&gt;connectChangedSignalTo(boost::bind(&amp;Foobar::param1Changed,</div><div class="line"><span class="keyword">this</span>, _1));</div><div class="line">}</div></div><!-- fragment --><p>The notification method takes as its sole argument a reference to the parameter whose value has changed. Here's the declaration for the param1Changed method refered to above:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> param1Changed(<span class="keyword">const</span> <a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">Parameter::IntValue</a>&amp; param);</div></div><!-- fragment --><p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> API guarantees that parameter notification methods like param1Changed above will not run while an algorithm is processing a message. Thus, an algorithm is safe to manipulate its own state due to a parameter change without concern for protecting or locking state data from access by a processor method.</p>
<h1><a class="anchor" id="status"></a>
Runtime Status</h1>
<p>All Algorithm objects, through their Controller manager, report status information to external entities via the ControllerStatus object. The <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application obtains periodic status updates from active Runner processes, and displays the status information to the user. The standard status display for an algorithm shows pending queue and recording queue sizes, current processing state, recording status (active, standby, or inactive), and any error text posted by the algorithm by way of Task::setError().</p>
<p>Algorithms desiring customized reporting information, should override the getInfoData() method, which is called by the algorithm's Controller when it wants updated status information. The sole parameter is an <a class="el" href="classXmlRpc_1_1XmlRpcValue.html" title="RPC method arguments and results are represented by Values. ">XmlRpc::XmlRpcValue</a> reference that may be used to store any valid XML-RPC value. The return value of the getInfoData() is a std::string that must be a unique value specific to the algorithm. The <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application expects to have a GUI::Master::InfoFormatter object defined under the same name as that returned by the getInfoData() method. The formattter object will receive the data stored by the algorithm, and reformatted it into a text string for presentation to the user.</p>
<p>A simplistic example of an specialized getInfoData() method appears below, where the Foobar algorithm echos the current value of its param1_ and param2_ runtime parameters in its status. Since there are two items, the routine starts by setting the given reference to size 2, which causes the reference to become an XML-RPC array:</p>
<div class="fragment"><div class="line">std::string</div><div class="line">Foobar::getInfoData(<a class="code" href="classXmlRpc_1_1XmlRpcValue.html">XmlRpc::XmlRpcValue</a>&amp; infoData)</div><div class="line">{</div><div class="line">infoData.<a class="code" href="classXmlRpc_1_1XmlRpcValue.html#af411c8368c750bd8b06801a7f0693bb0">setSize</a>(2);</div><div class="line">infoData[0] = <a class="code" href="classXmlRpc_1_1XmlRpcValue.html">XmlRpc::XmlRpcValue</a>(param1_-&gt;getValue());</div><div class="line">infoData[1] = <a class="code" href="classXmlRpc_1_1XmlRpcValue.html">XmlRpc::XmlRpcValue</a>(param2_-&gt;getValue());</div><div class="line"><span class="keywordflow">return</span> <span class="stringliteral">&quot;Foobar&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Again, the <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application needs an InfoFormatter object installed which understands how to format status information with the name "Foobar". See <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> documetation for instructions on how to do this.</p>
<h1><a class="anchor" id="logging"></a>
Logging</h1>
<p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> system contains a powerful logging facility. Each algorithm has its own log device, which it is given in the algorithm's constructor. The log device controls which log messages make it to a logging mechanism such as a file or a syslog daemon (see <a class="el" href="classLogger_1_1Log.html" title="Master class for the Logger system. ">Logger::Log</a> for the log device API).</p>
<p>The canonical way to use the algorithm's log device is to pass it to a procedural logger, defined by <a class="el" href="classLogger_1_1ProcLog.html" title="Utility class used to create log messages prefixed with a procedure name. ">Logger::ProcLog</a>. A prodecural logger takes two arguments in its constructor:</p>
<ul>
<li><code>name</code> the routine name containing the procedural log device</li>
<li><code>logger</code> the algorithm's log device (obtained from the getLog() method).</li>
</ul>
<p>If the procedural log device is named <code>log</code> then the following macros may be used in a routine to emit log messages at a particular log level:</p>
<ul>
<li><code>LOGFATAL</code> send a message with kFatal priority</li>
<li><code>LOGERROR</code> send a message with kError priority</li>
<li><code>LOGWARNING</code> send a message with kWarning priority</li>
<li><code>LOGINFO</code> send a message with kInfo priority</li>
<li><code>LOGDEBUG</code> send a message with kDebug priority</li>
</ul>
<p>Here's an example of an instrumented param1Changed method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">Foobar::param1Changed(<span class="keyword">const</span> <a class="code" href="namespaceSideCar_1_1Parameter.html#af5fda55fa7a18ae02afa17c4b233a31f">Parameter::IntValue</a>&amp; param)</div><div class="line">{</div><div class="line"><a class="code" href="classLogger_1_1ProcLog.html">Logger::ProcLog</a> log(<span class="stringliteral">&quot;param1Changed&quot;</span>, getLog());</div><div class="line"><a class="code" href="Log_8h.html#aa5225a678cd87ae1a247d0563073474e">LOGINFO</a> &lt;&lt; <span class="stringliteral">&quot;new value: &quot;</span> &lt;&lt; param.getValue() &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (param.getValue() &lt; 1) {</div><div class="line"><a class="code" href="Log_8h.html#a29b9525322b08a5b2bb7fa30ebc48214">LOGERROR</a> &lt;&lt; <span class="stringliteral">&quot;too small&quot;</span> &lt;&lt; std::endl;</div><div class="line">param1_-&gt;setValue(1);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.getValue() &gt; 10) {</div><div class="line"><a class="code" href="Log_8h.html#a29b9525322b08a5b2bb7fa30ebc48214">LOGERROR</a> &lt;&lt; <span class="stringliteral">&quot;too big&quot;</span> &lt;&lt; std::endl;</div><div class="line">param1_-&gt;setValue(10);</div><div class="line">}</div><div class="line"></div><div class="line">updateState();</div><div class="line">}</div></div><!-- fragment --><p>The macros actually expand to an <code>if</code> statement with a condition that checks if the log device accepts a message at the indicated priority, and if so, the <code>if</code> body gets executed which contains the stream insertion operations. As a result, log messages below the reporting level of the algorithm's log device incur very little overhead. Feel free to instrument your algorithm code with copious amounts of LOGDEBUG and LOGINFO statements without worry. Normal <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> behavior is to only emit log messages at kWarning or above. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
