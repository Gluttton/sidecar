<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SideCar: SideCar::Algorithms::ChannelBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SideCar
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSideCar.html">SideCar</a></li><li class="navelem"><a class="el" href="namespaceSideCar_1_1Algorithms.html">Algorithms</a></li><li class="navelem"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html">ChannelBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SideCar::Algorithms::ChannelBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class of an input message buffer that will hold a maximum number of messages in FIFO order.  
 <a href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ChannelBuffer_8h_source.html">/Users/howes/src/sidecar/Algorithms/ChannelBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SideCar::Algorithms::ChannelBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classSideCar_1_1Algorithms_1_1ChannelBuffer__inherit__graph.png" border="0" usemap="#SideCar_1_1Algorithms_1_1ChannelBuffer_inherit__map" alt="Inheritance graph"/></div>
<map name="SideCar_1_1Algorithms_1_1ChannelBuffer_inherit__map" id="SideCar_1_1Algorithms_1_1ChannelBuffer_inherit__map">
<area shape="rect" id="node2" href="classSideCar_1_1Algorithms_1_1TChannelBuffer.html" title="Templated class for a input channel buffer. " alt="" coords="212,5,362,54"/>
<area shape="rect" id="node3" href="classSideCar_1_1Algorithms_1_1TChannelBuffer.html" title="SideCar::Algorithms\l::TChannelBuffer\&lt; Messages\l::Video \&gt;" alt="" coords="192,79,383,146"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aadd495ab37e1d2c8d124d50b4d7f5504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadd495ab37e1d2c8d124d50b4d7f5504"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Container</b> = std::deque&lt; Messages::PRIMessage::Ref &gt;</td></tr>
<tr class="separator:aadd495ab37e1d2c8d124d50b4d7f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e94628f16319202f8f14f650ce7c6f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e94628f16319202f8f14f650ce7c6f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = Container::const_iterator</td></tr>
<tr class="separator:a3e94628f16319202f8f14f650ce7c6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28afd1d71cd87fc4ce135e22cce89bb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a28afd1d71cd87fc4ce135e22cce89bb5">ChannelBuffer</a> (<a class="el" href="classSideCar_1_1Algorithms_1_1ManyInAlgorithm.html">ManyInAlgorithm</a> &amp;processor, size_t channelIndex, size_t maxBufferSize)</td></tr>
<tr class="memdesc:a28afd1d71cd87fc4ce135e22cce89bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a28afd1d71cd87fc4ce135e22cce89bb5">More...</a><br /></td></tr>
<tr class="separator:a28afd1d71cd87fc4ce135e22cce89bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33afcf96de9773ea5dca002c2e222843"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a33afcf96de9773ea5dca002c2e222843">~ChannelBuffer</a> ()</td></tr>
<tr class="memdesc:a33afcf96de9773ea5dca002c2e222843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a33afcf96de9773ea5dca002c2e222843">More...</a><br /></td></tr>
<tr class="separator:a33afcf96de9773ea5dca002c2e222843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05addb7a710adf74517e6cc0c1581b25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a05addb7a710adf74517e6cc0c1581b25">getChannelIndex</a> () const </td></tr>
<tr class="memdesc:a05addb7a710adf74517e6cc0c1581b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the channel index for this object.  <a href="#a05addb7a710adf74517e6cc0c1581b25">More...</a><br /></td></tr>
<tr class="separator:a05addb7a710adf74517e6cc0c1581b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd6e452af05d8daa56f53404acbe798"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a4cd6e452af05d8daa56f53404acbe798">getMaxBufferSize</a> () const </td></tr>
<tr class="memdesc:a4cd6e452af05d8daa56f53404acbe798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum number of messages to hold.  <a href="#a4cd6e452af05d8daa56f53404acbe798">More...</a><br /></td></tr>
<tr class="separator:a4cd6e452af05d8daa56f53404acbe798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d973f8524e14860538cd890ea9dda4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a9d973f8524e14860538cd890ea9dda4c">size</a> () const </td></tr>
<tr class="memdesc:a9d973f8524e14860538cd890ea9dda4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of messages in the buffer.  <a href="#a9d973f8524e14860538cd890ea9dda4c">More...</a><br /></td></tr>
<tr class="separator:a9d973f8524e14860538cd890ea9dda4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc19c68861e27834b12ad70f5a89f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#aaabc19c68861e27834b12ad70f5a89f2">isEmpty</a> () const </td></tr>
<tr class="memdesc:aaabc19c68861e27834b12ad70f5a89f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the buffer is empty.  <a href="#aaabc19c68861e27834b12ad70f5a89f2">More...</a><br /></td></tr>
<tr class="separator:aaabc19c68861e27834b12ad70f5a89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8906235e4cae9833a8bde584f87187d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ad8906235e4cae9833a8bde584f87187d">isEnabled</a> () const </td></tr>
<tr class="memdesc:ad8906235e4cae9833a8bde584f87187d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the buffer is enabled.  <a href="#ad8906235e4cae9833a8bde584f87187d">More...</a><br /></td></tr>
<tr class="separator:ad8906235e4cae9833a8bde584f87187d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922be5abcc4dc91e0cce36921fdad0f2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a922be5abcc4dc91e0cce36921fdad0f2">getNextSequenceCounter</a> () const </td></tr>
<tr class="memdesc:a922be5abcc4dc91e0cce36921fdad0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the sequence counter of the first message in the queue.  <a href="#a922be5abcc4dc91e0cce36921fdad0f2">More...</a><br /></td></tr>
<tr class="separator:a922be5abcc4dc91e0cce36921fdad0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab539a962e90e079558af854833751af9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ab539a962e90e079558af854833751af9">pruneToSequenceCounter</a> (uint32_t sequenceCounter)</td></tr>
<tr class="memdesc:ab539a962e90e079558af854833751af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove messages from the front of the queue whose sequence counter values are less than the given value.  <a href="#ab539a962e90e079558af854833751af9">More...</a><br /></td></tr>
<tr class="separator:ab539a962e90e079558af854833751af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fdc7335776c62a3271634569d58540"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#aa2fdc7335776c62a3271634569d58540">setMaxBufferSize</a> (size_t maxBufferSize)</td></tr>
<tr class="memdesc:aa2fdc7335776c62a3271634569d58540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the maximum number of messages to hold.  <a href="#aa2fdc7335776c62a3271634569d58540">More...</a><br /></td></tr>
<tr class="separator:aa2fdc7335776c62a3271634569d58540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d466eaa7de06ab8c58e46ab79c87b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a7b6d466eaa7de06ab8c58e46ab79c87b">setEnabled</a> (bool value)</td></tr>
<tr class="memdesc:a7b6d466eaa7de06ab8c58e46ab79c87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the enabled state.  <a href="#a7b6d466eaa7de06ab8c58e46ab79c87b">More...</a><br /></td></tr>
<tr class="separator:a7b6d466eaa7de06ab8c58e46ab79c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c72c9a008248231c71cd6d15b40f70a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c72c9a008248231c71cd6d15b40f70a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a2c72c9a008248231c71cd6d15b40f70a">reset</a> ()</td></tr>
<tr class="memdesc:a2c72c9a008248231c71cd6d15b40f70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the buffer by forgetting any held messagess. <br /></td></tr>
<tr class="separator:a2c72c9a008248231c71cd6d15b40f70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e170946ce5611834e7a3255060b7e21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a5e170946ce5611834e7a3255060b7e21">getSlice</a> (int offset, int span, VsipComplexVector &amp;slice, bool doPop)=0</td></tr>
<tr class="memdesc:a5e170946ce5611834e7a3255060b7e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a slide of the data, copying it into a VSIPL vector.  <a href="#a5e170946ce5611834e7a3255060b7e21">More...</a><br /></td></tr>
<tr class="separator:a5e170946ce5611834e7a3255060b7e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7252a9a070ce6fb6e1dd7955b7d7c94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ad7252a9a070ce6fb6e1dd7955b7d7c94">addData</a> (const Messages::PRIMessage::Ref &amp;msg)</td></tr>
<tr class="memdesc:ad7252a9a070ce6fb6e1dd7955b7d7c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a message to the queue.  <a href="#ad7252a9a070ce6fb6e1dd7955b7d7c94">More...</a><br /></td></tr>
<tr class="separator:ad7252a9a070ce6fb6e1dd7955b7d7c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f63c1627281941d2dd4971c901b833"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ab4f63c1627281941d2dd4971c901b833">makeEnabledParameter</a> ()</td></tr>
<tr class="memdesc:ab4f63c1627281941d2dd4971c901b833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a runtime parameter to control the channel enabled state.  <a href="#ab4f63c1627281941d2dd4971c901b833">More...</a><br /></td></tr>
<tr class="separator:ab4f63c1627281941d2dd4971c901b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd164dea0d4ebf6db140c5c8a0de9e12"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#afd164dea0d4ebf6db140c5c8a0de9e12">makeEnabledParameter</a> (const std::string &amp;shortName, const std::string &amp;longName)</td></tr>
<tr class="memdesc:afd164dea0d4ebf6db140c5c8a0de9e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a runtime parameter to control the channel enabled state.  <a href="#afd164dea0d4ebf6db140c5c8a0de9e12">More...</a><br /></td></tr>
<tr class="separator:afd164dea0d4ebf6db140c5c8a0de9e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93092eab32d5be81bda69bdd2130b1ac"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a93092eab32d5be81bda69bdd2130b1ac">begin</a> () const </td></tr>
<tr class="memdesc:a93092eab32d5be81bda69bdd2130b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain read-only iterator to the first sample value in the message.  <a href="#a93092eab32d5be81bda69bdd2130b1ac">More...</a><br /></td></tr>
<tr class="separator:a93092eab32d5be81bda69bdd2130b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1678667ba5ab0a1a2207e94f04c9c4f6"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a1678667ba5ab0a1a2207e94f04c9c4f6">end</a> () const </td></tr>
<tr class="memdesc:a1678667ba5ab0a1a2207e94f04c9c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain read-only iterator to the last + 1 sample value in the message.  <a href="#a1678667ba5ab0a1a2207e94f04c9c4f6">More...</a><br /></td></tr>
<tr class="separator:a1678667ba5ab0a1a2207e94f04c9c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f6c4cac65829f3a1467731f080cfc7"><td class="memItemLeft" align="right" valign="top">Messages::PRIMessage::Ref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#af5f6c4cac65829f3a1467731f080cfc7">getFront</a> () const </td></tr>
<tr class="memdesc:af5f6c4cac65829f3a1467731f080cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the oldest message in the queue.  <a href="#af5f6c4cac65829f3a1467731f080cfc7">More...</a><br /></td></tr>
<tr class="separator:af5f6c4cac65829f3a1467731f080cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cbcb2126eb18bda9c80d84f8c04072"><td class="memItemLeft" align="right" valign="top">Messages::PRIMessage::Ref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a29cbcb2126eb18bda9c80d84f8c04072">popFront</a> ()</td></tr>
<tr class="memdesc:a29cbcb2126eb18bda9c80d84f8c04072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the oldest message in the queue.  <a href="#a29cbcb2126eb18bda9c80d84f8c04072">More...</a><br /></td></tr>
<tr class="separator:a29cbcb2126eb18bda9c80d84f8c04072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa1b816dcaa7a9334dcd4ee0a4b350e1e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#aa1b816dcaa7a9334dcd4ee0a4b350e1e">MakeGenericShortName</a> (int index)</td></tr>
<tr class="memdesc:aa1b816dcaa7a9334dcd4ee0a4b350e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create generic short name for the input channel.  <a href="#aa1b816dcaa7a9334dcd4ee0a4b350e1e">More...</a><br /></td></tr>
<tr class="separator:aa1b816dcaa7a9334dcd4ee0a4b350e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1063633e6f255f9e9decf6353b1aaa8"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ac1063633e6f255f9e9decf6353b1aaa8">MakeGenericLongName</a> (int index)</td></tr>
<tr class="memdesc:ac1063633e6f255f9e9decf6353b1aaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create generic long name for the input channel.  <a href="#ac1063633e6f255f9e9decf6353b1aaa8">More...</a><br /></td></tr>
<tr class="separator:ac1063633e6f255f9e9decf6353b1aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1d3186d4df4a668939966648e1e33d3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a1d3186d4df4a668939966648e1e33d3b">popFrontInternal</a> ()</td></tr>
<tr class="memdesc:a1d3186d4df4a668939966648e1e33d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the oldest message from the queue.  <a href="#a1d3186d4df4a668939966648e1e33d3b">More...</a><br /></td></tr>
<tr class="separator:a1d3186d4df4a668939966648e1e33d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab265e050288d663c8ebb0da98c7976a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab265e050288d663c8ebb0da98c7976a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ab265e050288d663c8ebb0da98c7976a0">pruneToMaxBufferSize</a> ()</td></tr>
<tr class="memdesc:ab265e050288d663c8ebb0da98c7976a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove messages until the size of the buffer is less than or equal to maxBufferSize_. <br /></td></tr>
<tr class="separator:ab265e050288d663c8ebb0da98c7976a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b90db9a68b50e3d8cbb70402e6a500d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a9b90db9a68b50e3d8cbb70402e6a500d">enabledChanged</a> (const <a class="el" href="namespaceSideCar_1_1Parameter.html#ae7fd81f2aa0c88ba3ec277b3bb7d6c98">Parameter::BoolValue</a> &amp;parameter)</td></tr>
<tr class="memdesc:a9b90db9a68b50e3d8cbb70402e6a500d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked when the 'enabled' parameter state changes.  <a href="#a9b90db9a68b50e3d8cbb70402e6a500d">More...</a><br /></td></tr>
<tr class="separator:a9b90db9a68b50e3d8cbb70402e6a500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class of an input message buffer that will hold a maximum number of messages in FIFO order. </p>
<p>Held messages are of type PRIMessage; a derived template class, <a class="el" href="classSideCar_1_1Algorithms_1_1TChannelBuffer.html" title="Templated class for a input channel buffer. ">TChannelBuffer</a>, works with concrete <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> messages types.</p>
<p>Note that this class works with a <a class="el" href="classSideCar_1_1Algorithms_1_1ManyInAlgorithm.html" title="Derivation of the basic Algorithm class that handles multiple input channels using ChannelBuffer obje...">ManyInAlgorithm</a> instance, requiring one in its constructor. After a <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html" title="Abstract base class of an input message buffer that will hold a maximum number of messages in FIFO or...">ChannelBuffer</a> places a new message in its queue, it calls the <a class="el" href="classSideCar_1_1Algorithms_1_1ManyInAlgorithm.html#a1a585db78e23f9df7c446ab59358238f" title="Process the ChannelBuffer objects. ">ManyInAlgorithm::processMessageReceived()</a> method to notify the <a class="el" href="classSideCar_1_1Algorithms_1_1ManyInAlgorithm.html" title="Derivation of the basic Algorithm class that handles multiple input channels using ChannelBuffer obje...">ManyInAlgorithm</a> object of new data. </p>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00029">29</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a28afd1d71cd87fc4ce135e22cce89bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelBuffer::ChannelBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSideCar_1_1Algorithms_1_1ManyInAlgorithm.html">ManyInAlgorithm</a> &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>channelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>object to notify when new data arrives in the buffer</td></tr>
    <tr><td class="paramname">channelIndex</td><td>the channel index unique to this object</td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>the maximum number of messages to hold </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00024">24</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a33afcf96de9773ea5dca002c2e222843"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChannelBuffer::~ChannelBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Properly dispose of any held messages. </p>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00031">31</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad7252a9a070ce6fb6e1dd7955b7d7c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelBuffer::addData </td>
          <td>(</td>
          <td class="paramtype">const Messages::PRIMessage::Ref &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a message to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00096">96</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8h_source.html#l00096">isEnabled()</a>, <a class="el" href="ManyInAlgorithm_8cc_source.html#l00179">SideCar::Algorithms::ManyInAlgorithm::processMessageReceived()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00117">pruneToMaxBufferSize()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="a93092eab32d5be81bda69bdd2130b1ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator SideCar::Algorithms::ChannelBuffer::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain read-only iterator to the first sample value in the message. </p>
<dl class="section return"><dt>Returns</dt><dd>read-only iterator </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00172">172</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b90db9a68b50e3d8cbb70402e6a500d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelBuffer::enabledChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSideCar_1_1Parameter.html#ae7fd81f2aa0c88ba3ec277b3bb7d6c98">Parameter::BoolValue</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback invoked when the 'enabled' parameter state changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>the parameter that changed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00051">51</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="Parameter_8h_source.html#l00297">SideCar::Parameter::TValue&lt; ParamDef &gt;::getValue()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00081">setEnabled()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00043">makeEnabledParameter()</a>, and <a class="el" href="ChannelBuffer_8h_source.html#l00188">popFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a1678667ba5ab0a1a2207e94f04c9c4f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator SideCar::Algorithms::ChannelBuffer::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain read-only iterator to the last + 1 sample value in the message. </p>
<dl class="section return"><dt>Returns</dt><dd>read-only iterator </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00178">178</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05addb7a710adf74517e6cc0c1581b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SideCar::Algorithms::ChannelBuffer::getChannelIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the channel index for this object. </p>
<dl class="section return"><dt>Returns</dt><dd>channel index </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00072">72</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="SimpleOp_8cc_source.html#l00025">SideCar::Algorithms::SimpleOp::SimpleOp()</a>, and <a class="el" href="Summer_8cc_source.html#l00016">SideCar::Algorithms::Summer::Summer()</a>.</p>

</div>
</div>
<a class="anchor" id="af5f6c4cac65829f3a1467731f080cfc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Messages::PRIMessage::Ref SideCar::Algorithms::ChannelBuffer::getFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the oldest message in the queue. </p>
<p>NOTE: only call if the queue is not empty.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSideCar_1_1Messages_1_1PRIMessage.html" title="Base class for all PRI-type messages created in the SideCar. ">Messages::PRIMessage</a> reference </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00184">184</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00246">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::getFront()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00281">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::getSlice()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00188">popFront()</a>, and <a class="el" href="ChannelBuffer_8h_source.html#l00256">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::popFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cd6e452af05d8daa56f53404acbe798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SideCar::Algorithms::ChannelBuffer::getMaxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the maximum number of messages to hold. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer limit </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00078">78</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a922be5abcc4dc91e0cce36921fdad0f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SideCar::Algorithms::ChannelBuffer::getNextSequenceCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the sequence counter of the first message in the queue. </p>
<p>NOTE: if the queue is empty, this returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>sequence counter </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00103">103</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8cc_source.html#l00096">addData()</a>, <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#a5e170946ce5611834e7a3255060b7e21">getSlice()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00037">makeEnabledParameter()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00059">pruneToSequenceCounter()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00089">reset()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00081">setEnabled()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00074">setMaxBufferSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e170946ce5611834e7a3255060b7e21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SideCar::Algorithms::ChannelBuffer::getSlice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>span</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VsipComplexVector &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doPop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a slide of the data, copying it into a VSIPL vector. </p>
<p>NOTE: only valid if <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#aaabc19c68861e27834b12ad70f5a89f2" title="Determine if the buffer is empty. ">isEmpty()</a> is false. Always works on the first message in the FIFO queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>index of the first sample value to use</td></tr>
    <tr><td class="paramname">span</td><td>count of sample values to gather</td></tr>
    <tr><td class="paramname">slice</td><td>container to hold the resulting complex values</td></tr>
    <tr><td class="paramname">doPop</td><td>if true, remove the first message from the queue after working with it </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSideCar_1_1Algorithms_1_1TChannelBuffer.html#a511dd9c7208bb179cd43590086464530">SideCar::Algorithms::TChannelBuffer&lt; T &gt;</a>, and <a class="el" href="classSideCar_1_1Algorithms_1_1TChannelBuffer.html#a511dd9c7208bb179cd43590086464530">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="aaabc19c68861e27834b12ad70f5a89f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SideCar::Algorithms::ChannelBuffer::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if so </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00090">90</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00246">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::getFront()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00281">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::getSlice()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00188">popFront()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00256">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::popFront()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00108">popFrontInternal()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00059">pruneToSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8906235e4cae9833a8bde584f87187d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SideCar::Algorithms::ChannelBuffer::isEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the buffer is enabled. </p>
<p>A disabled buffer ignores all <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ad7252a9a070ce6fb6e1dd7955b7d7c94" title="Add a message to the queue. ">addData()</a> calls.</p>
<dl class="section return"><dt>Returns</dt><dd>true if so </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00096">96</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00096">addData()</a>, <a class="el" href="ManyInAlgorithm_8h_source.html#l00131">SideCar::Algorithms::ManyInAlgorithm::getNumInfoSlots()</a>, <a class="el" href="SimpleOp_8cc_source.html#l00025">SideCar::Algorithms::SimpleOp::SimpleOp()</a>, and <a class="el" href="Summer_8cc_source.html#l00016">SideCar::Algorithms::Summer::Summer()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f63c1627281941d2dd4971c901b833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelBuffer::makeEnabledParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a runtime parameter to control the channel enabled state. </p>
<p>The created <a class="el" href="namespaceSideCar_1_1Parameter.html#ae7fd81f2aa0c88ba3ec277b3bb7d6c98" title="Definition of a boolean parameter. ">Parameter::BoolValue</a> object will have names created from <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#aa1b816dcaa7a9334dcd4ee0a4b350e1e" title="Create generic short name for the input channel. ">MakeGenericShortName()</a> and <a class="el" href="classSideCar_1_1Algorithms_1_1ChannelBuffer.html#ac1063633e6f255f9e9decf6353b1aaa8" title="Create generic long name for the input channel. ">MakeGenericLongName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00037">37</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8cc_source.html#l00017">MakeGenericLongName()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00009">MakeGenericShortName()</a>.</p>

<p>Referenced by <a class="el" href="BinaryOp_8cc_source.html#l00028">SideCar::Algorithms::BinaryOp::BinaryOp()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>, <a class="el" href="SimpleOp_8cc_source.html#l00025">SideCar::Algorithms::SimpleOp::SimpleOp()</a>, and <a class="el" href="Summer_8cc_source.html#l00016">SideCar::Algorithms::Summer::Summer()</a>.</p>

</div>
</div>
<a class="anchor" id="afd164dea0d4ebf6db140c5c8a0de9e12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelBuffer::makeEnabledParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>longName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a runtime parameter to control the channel enabled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortName</td><td></td></tr>
    <tr><td class="paramname">longName</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00043">43</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8cc_source.html#l00051">enabledChanged()</a>, <a class="el" href="Parameter_8h_source.html#l00257">SideCar::Parameter::TValue&lt; ParamDef &gt;::Make()</a>, and <a class="el" href="Algorithm_8h_source.html#l00128">SideCar::Algorithms::Algorithm::registerParameter()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1063633e6f255f9e9decf6353b1aaa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ChannelBuffer::MakeGenericLongName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create generic long name for the input channel. </p>
<p>Given an index value of N, this will return a string with the format "Input # Enabled", with # replaced by the value N+1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the channel index to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generic short name </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00017">17</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00037">makeEnabledParameter()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1b816dcaa7a9334dcd4ee0a4b350e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ChannelBuffer::MakeGenericShortName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create generic short name for the input channel. </p>
<p>Given an index value of N, this will return a string with the format "input#Enabled", with # replaced by the value N+1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the channel index to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generic short name </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00009">9</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00037">makeEnabledParameter()</a>.</p>

</div>
</div>
<a class="anchor" id="a29cbcb2126eb18bda9c80d84f8c04072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Messages::PRIMessage::Ref SideCar::Algorithms::ChannelBuffer::popFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the oldest message in the queue. </p>
<p>NOTE: only call if the queue is not empty. </p>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00188">188</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8cc_source.html#l00051">enabledChanged()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00184">getFront()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00090">isEmpty()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00108">popFrontInternal()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00117">pruneToMaxBufferSize()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00281">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::getSlice()</a>, and <a class="el" href="Printer_8cc_source.html#l00041">SideCar::Algorithms::Printer::startup()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d3186d4df4a668939966648e1e33d3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelBuffer::popFrontInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the oldest message from the queue. </p>
<p>Updates the nextSequenceCounter_ value. NOTE: only call if the queue is not empty. </p>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00108">108</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8h_source.html#l00090">isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00188">popFront()</a>, <a class="el" href="ChannelBuffer_8h_source.html#l00256">SideCar::Algorithms::TChannelBuffer&lt; Messages::Video &gt;::popFront()</a>, <a class="el" href="ChannelBuffer_8cc_source.html#l00117">pruneToMaxBufferSize()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00059">pruneToSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="ab539a962e90e079558af854833751af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelBuffer::pruneToSequenceCounter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sequenceCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove messages from the front of the queue whose sequence counter values are less than the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequenceCounter</td><td>the value to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer has a message with the given sequence counter </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00059">59</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8h_source.html#l00090">isEmpty()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00108">popFrontInternal()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b6d466eaa7de06ab8c58e46ab79c87b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelBuffer::setEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the enabled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>new value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00081">81</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ManyInAlgorithm_8cc_source.html#l00172">SideCar::Algorithms::ManyInAlgorithm::channelEnabledChanged()</a>, and <a class="el" href="ChannelBuffer_8cc_source.html#l00089">reset()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00051">enabledChanged()</a>, and <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2fdc7335776c62a3271634569d58540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelBuffer::setMaxBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the maximum number of messages to hold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxBufferSize</td><td>new value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8cc_source.html#l00074">74</a> of file <a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a>.</p>

<p>References <a class="el" href="ChannelBuffer_8cc_source.html#l00117">pruneToMaxBufferSize()</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8h_source.html#l00103">getNextSequenceCounter()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d973f8524e14860538cd890ea9dda4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SideCar::Algorithms::ChannelBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the number of messages in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer size </dd></dl>

<p>Definition at line <a class="el" href="ChannelBuffer_8h_source.html#l00084">84</a> of file <a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="ChannelBuffer_8cc_source.html#l00117">pruneToMaxBufferSize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/howes/src/sidecar/Algorithms/<a class="el" href="ChannelBuffer_8h_source.html">ChannelBuffer.h</a></li>
<li>/Users/howes/src/sidecar/Algorithms/<a class="el" href="ChannelBuffer_8cc_source.html">ChannelBuffer.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
