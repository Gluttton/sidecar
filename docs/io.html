<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SideCar: SideCar Component Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SideCar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Radar SideCar Project</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> Component Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> system is built on top of the <a href="http://www.cs.wustl.edu/~schmidt/ACE.html">Adaptive Communication Environment</a> (ACE) object-oriented network programming toolkit.</p>
<p>In particular, it relies on ACE classes to perform nearly all of the low-level socket and file IO in a system independent way &ndash; ACE runs on a wide variety of Unix platforms, Apple MacOS X, and MS Windows systems.</p>
<p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> framework contains light-weight derivation of the following powerful ACE classes:</p>
<ul>
<li>ACE_Stream (<a class="el" href="classSideCar_1_1IO_1_1Stream.html" title="A SideCar data stream. ">SideCar::IO::Stream</a>)</li>
<li>ACE_Module (<a class="el" href="classSideCar_1_1IO_1_1Module.html" title="Derivation of the ACE_Module class for use in Stream objects. ">SideCar::IO::Module</a> and <a class="el" href="classSideCar_1_1IO_1_1TModule.html" title="Template class for creating Module objects containing Task objects. ">SideCar::IO::TModule</a>)</li>
<li>ACE_Task (<a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a>)</li>
</ul>
<p>An ACE_Stream object contains one or more ACE_Module objects, which in turn contain one or two ACE_Task objects, the number depending on whether the stream supports unidirectional or bidirectional message flow.</p>
<p>Messages flow from task to task via their <code>put()</code> and <code>put_next()</code> methods. If a task processes data in a separate thread, then the <code>put()</code> method usually places the incoming message into an ACE_Message_Queue that contains appropriate mutex protection for multi-threaded access. The <code>put_next()</code> method forwards a message to the next entity linked to the task.</p>
<p>The <a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> infrastructure uses the ACE stream mechanics without modification. However, its own <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> class adds a runtime state graph that properly manages transitions from on run state to another (see <a class="el" href="classSideCar_1_1IO_1_1ProcessingState.html" title="Representation of a processing state in the SideCar system. ">SideCar::IO::ProcessingState</a>). <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> also manages and manipulates the message flow by treating control and data messages separately, giving them each their own control flow within <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a>. This allows <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> and its decendents to deliver and process control messages and data messages in different ways. Here is the call chains for control messages:</p>
<ul>
<li><a class="el" href="classSideCar_1_1IO_1_1Task.html#a8bf198fcc4ca42f0bd716f52853bee78" title="Override of ACE_Task method. ">SideCar::IO::Task::put()</a> entry point into message processing</li>
<li>SideCar::IO::Task::put_next() forward the control message to the next task in the stream</li>
<li><a class="el" href="classSideCar_1_1IO_1_1Task.html#a3d5356c2bf496e7f43d4490991542459" title="Give a control message to the task. ">SideCar::IO::Task::deliverControlMessage()</a> accept the message</li>
<li><a class="el" href="classSideCar_1_1IO_1_1Task.html#aa202b75c08494c25de56c57bb2af642d" title="Process a control message. ">SideCar::IO::Task::processControlMessage()</a> invoke a 'do' method based on the type of control message given. See <a class="el" href="classSideCar_1_1IO_1_1ControlMessage.html" title="Base class for all SideCar control messages. ">SideCar::IO::ControlMessage</a> for an enumeration of control types. Each message type has its own handler in <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> (eg. doProcessingStateChange(), doRecordingStateChange()) which derived classes may override.</li>
</ul>
<p>Handling of data messages is a little more complex. Firstly, <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> does not do data processing; derived classes must define the deliverDataMessage() and processDataMessage() methods. Also, data messages have a list of recipients, placed on the messsage when the message was first emitted from a task. The list of recipients identifies which tasks in a processing stream should see the messsage. The big benefit of this is that if a task is not interested in a message, the message will never reach its message queue for processing, thus reducing the load of any service thread running to process data from the message queue and removing the need to mutex lock the message queue for message delivery.</p>
<p>However, if a task is the next recipient of a message, the call flow is as follows:</p>
<ul>
<li><a class="el" href="classSideCar_1_1IO_1_1Task.html#a8bf198fcc4ca42f0bd716f52853bee78" title="Override of ACE_Task method. ">SideCar::IO::Task::put()</a> entry point into message processing (same as for control flow)</li>
<li><a class="el" href="classSideCar_1_1IO_1_1Task.html#ad67e32d9ed466a6e2339785e9178856b" title="Give a message to the task to do with as it pleases. ">SideCar::IO::Task::deliverDataMessage()</a> perform message delivery. For most classed derived from <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> (eg. <a class="el" href="classSideCar_1_1Algorithms_1_1Controller.html" title="Controller for an Algorithm object found in a separate DLL. ">SideCar::Algorithms::Controller</a>), messages are simply added to its message queue, and a separate thread will perform the actual work on the message when it gets time to do so.</li>
</ul>
<p>The <a class="el" href="classSideCar_1_1IO_1_1Stream.html" title="A SideCar data stream. ">SideCar::IO::Stream</a>, <a class="el" href="classSideCar_1_1IO_1_1Module.html" title="Derivation of the ACE_Module class for use in Stream objects. ">SideCar::IO::Module</a>, and <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> classes all support status reporting, the results of which are periodically sent out to interested parties such as the <a class="el" href="namespaceSideCar_1_1GUI_1_1Master.html" title="Namespace for the Master application. ">SideCar::GUI::Master</a> application. A stream collects status from each of its modules, which in turn collect status from its task object (<a class="el" href="namespaceSideCar.html" title="Namespace for all entities specific to the 331 SideCar project. ">SideCar</a> streams are unidirectional in data flow; thus a <a class="el" href="classSideCar_1_1IO_1_1Module.html" title="Derivation of the ACE_Module class for use in Stream objects. ">SideCar::IO::Module</a> only contains one <a class="el" href="classSideCar_1_1IO_1_1Task.html" title="Derivation of ACE_Task for SideCar processing modules. ">SideCar::IO::Task</a> object.) </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
